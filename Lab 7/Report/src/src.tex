\section{Описание}
Нужно аккуратно пересчитать количество палиндромов. Начинаем с базового случая -- пустое слово. У нас есть 2 основных варианта -- текущий палиндром имеет четную длину или нечетную. В случае, когда палиндром имеет четную длину мы можем добавить любую букву между центральными буквами -- получим палиндром нечетной длины. Для него же можно между центральными буквами искать такую же как и левая центральная буква. Добавив его, мы получим новый палиндром уже четной длины.

Основываясь на данных наблюдениях я придумал следующий вариант решения: создадим 2 функции для пересчета палиндромов четной и нечетной длины, каждая их них в качестве аргументов будет принимать ссылку на исходную строку и границы центральных букв.

Четный палиндром будет для каждой буквы между центральными ставить её как новую правую границу и запускать выполнение подсчета нечетного палиндрома.

Нечетный палиндром будет в переданном интервале искать букву равную букве правой границы, ставить её как новую правую границу и запускать выполнение подсчета четного палиндрома.

Т.к. у нас могут встречаться перекрестные задачи в целях оптимизации следует зделать кэш для этих задач, чтобы их заного не пересчитывать. Добавлять в кэш стоит только результаты четного пересчета, брать же можно как из четного, так и из нечетного пересчета.

\pagebreak

\section{Исходный код}

\begin{minted}{c++}
#include <iostream>

using ull = unsigned long long;
#define MAX_LEN 110

size_t cache[MAX_LEN][MAX_LEN]{0};

// Считает варианты, если длина текущего полиндрома нечетная
size_t calcOdd(std::string &s, size_t l, size_t r);

// Считает варианты, если длина текущего полиндрома четная
size_t calcEven(std::string &s, size_t l, size_t r) {
  if(cache[l][r] != 0)
    return cache[l][r];

  size_t result = 0;
  for(size_t i = l; i < r; ++i) {
    // std::cout << "E: " << s[i] << std::endl; 
    result += 1 + calcOdd(s, i, r);
  }

  cache[l][r] = result;
  return result;
}

size_t calcOdd(std::string &s, size_t l, size_t r) {
  if(cache[l][r] != 0)
    return cache[l][r];
  size_t result = 0;
  for(size_t i = l + 1; i < r; ++i) {
    if(s[i] == s[l]) {
      result += 1 + calcEven(s, l+1, i);
    }
  }

  //cache[l][r] = result;
  return result;
}

int main() {

  std::string s;
  std::cin >> s;
  
  ull result = calcEven(s, 0, s.size());

  std::cout << result << std::endl;
  return 0;
}
\end{minted}

\section{Консоль}
\begin{alltt}
raison@raison-Lenovo:~/git/Discrete-Analysis/Lab 7/Report$ ../../build/Lab\ 7/Lab7_main 
BAOBAB
22
\end{alltt}
\pagebreak
